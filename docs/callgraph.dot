digraph callgraph {
	graph [rankdir=LR];
	"post_io._parse_block"	[shape=box,
		tooltip="Return metadata dict and remaining body from ``text``."];
	"post_io.get_contact"	[shape=box,
		tooltip="Return a contact identifier from ``meta`` or ``None`` when missing."];
	"post_io.get_timestamp"	[shape=box,
		tooltip="Return ``meta['date']`` as a timezone-aware ``datetime``."];
	"post_io.read_post"	[shape=box,
		tooltip="Return metadata dictionary and body text for ``path``."];
	"post_io.read_post" -> "post_io._parse_block"	[minlen=1];
	"serde_utils.read_md"	[shape=box,
		tooltip="Alias for :func:`read_text` used for Markdown files."];
	"post_io.read_post" -> "serde_utils.read_md";
	"post_io.write_post"	[shape=box,
		tooltip="Write metadata and body as a Markdown post."];
	"post_io.write_post" -> "post_io.get_contact"	[minlen=1];
	"post_io.write_post" -> "post_io.get_timestamp"	[minlen=2];
	"serde_utils.write_md"	[shape=box,
		tooltip="Write ``text`` to ``path`` ensuring a trailing newline."];
	"post_io.write_post" -> "serde_utils.write_md";
	"post_io.raw_post_path"	[shape=box,
		tooltip="Return absolute message path for ``rel`` under ``root``."];
	"post_io.raw_post_path_from_lot"	[shape=box,
		tooltip="Return raw post path referenced by ``lot`` or ``None``."];
	"post_io.raw_post_path_from_lot" -> "post_io.raw_post_path"	[minlen=1];
	"telegram_bot._t"	[shape=box,
		tooltip="Return ``text`` translated to ``lang`` using gettext files."];
	"telegram_bot.save_state"	[shape=box];
	"telegram_bot._t" -> "telegram_bot.save_state"	[style=invis];
	"telegram_bot.ensure_profile"	[shape=box,
		tooltip="Return profile for ``uid`` creating one if needed."];
	"telegram_bot.save_profiles"	[shape=box,
		tooltip="Write ``profiles`` to disk."];
	"telegram_bot.ensure_profile" -> "telegram_bot.save_profiles"	[minlen=1];
	"telegram_bot.load_profiles"	[shape=box,
		tooltip="Populate the global ``profiles`` mapping."];
	"serde_utils.read_text"	[shape=box,
		tooltip="Return file contents as UTF-8 or empty string when missing."];
	"telegram_bot.load_profiles" -> "serde_utils.read_text"	[minlen=1];
	"telegram_bot.load_state"	[shape=box,
		tooltip="Populate ``processed_ids`` from ``STATE_PATH``."];
	"telegram_bot.load_state" -> "serde_utils.read_text"	[minlen=2];
	"phone_utils.format_georgian"	[shape=box,
		tooltip="Return ``phone`` in ``+995...`` format if possible."];
	"telegram_bot.save_state" -> "phone_utils.format_georgian"	[style=invis];
	"telegram_bot.scan_embeddings"	[shape=box,
		tooltip="Load new embeddings and return list of new lot ids."];
	"similar_utils._load_embeddings"	[shape=box,
		tooltip="Return mapping of lot id to embedding vector."];
	"telegram_bot.scan_embeddings" -> "similar_utils._load_embeddings"	[minlen=1];
	"telegram_bot._should_suggest"	[shape=box];
	"similar_utils._cos_sim"	[shape=box,
		tooltip="Return cosine similarity between two embeddings."];
	"telegram_bot._should_suggest" -> "similar_utils._cos_sim";
	"telegram_bot.enqueue_new_ids"	[shape=box];
	"telegram_bot.enqueue_new_ids" -> "telegram_bot.save_profiles";
	"telegram_bot.enqueue_new_ids" -> "telegram_bot._should_suggest"	[minlen=1];
	"build_site._load_ontology"	[shape=box];
	"serde_utils.load_json"	[shape=box,
		tooltip="Return parsed JSON or ``None`` when invalid."];
	"build_site._load_ontology" -> "serde_utils.load_json";
	"build_site._compile_locale"	[shape=box];
	"build_site._env_for_lang"	[shape=box];
	"build_site._env_for_lang" -> "build_site._compile_locale"	[minlen=1];
	"build_site._iter_lots"	[shape=box,
		tooltip="Return all lots ready for rendering."];
	"build_site._iter_lots" -> "post_io.read_post";
	"build_site._iter_lots" -> "post_io.raw_post_path";
	"moderation.should_skip_message"	[shape=box,
		tooltip="Return ``True`` when the raw Telegram message should be ignored."];
	"build_site._iter_lots" -> "moderation.should_skip_message";
	"moderation.should_skip_lot"	[shape=box,
		tooltip="Return ``True`` when the lot fails additional checks."];
	"build_site._iter_lots" -> "moderation.should_skip_lot";
	"lot_io.read_lots"	[shape=box,
		tooltip="Return a list of lots from ``path`` or ``None`` when invalid."];
	"build_site._iter_lots" -> "lot_io.read_lots";
	"lot_io.iter_lot_files"	[shape=box,
		tooltip="Return ``*.json`` files under ``root``.

When ``newest_first`` is ``True`` the result is ordered by modification
time with the most \
recently changed files first.  Both ``build_site.py`` and
``pending_embed.py`` rely on this helper so they scan the lot directory \
in
the same order."];
	"build_site._iter_lots" -> "lot_io.iter_lot_files"	[minlen=1];
	"build_site._copy_images"	[shape=box];
	"build_site._copy_static"	[shape=box,
		tooltip="Copy CSS and JS so generated pages are standalone."];
	"build_site._load_state"	[shape=box,
		tooltip="Return ontology fields, embeddings, lots and similarity cache."];
	"build_site._load_state" -> "build_site._load_ontology"	[minlen=1];
	"build_site._load_state" -> "build_site._iter_lots";
	"build_site._load_state" -> "build_site._copy_images"	[minlen=2];
	"build_site._load_state" -> "similar_utils._load_embeddings";
	"similar_utils._load_similar"	[shape=box,
		tooltip="Return cached similar lots mapping."];
	"build_site._load_state" -> "similar_utils._load_similar"	[minlen=3];
	"build_site._sync_embeddings"	[shape=box,
		tooltip="Drop lots or vectors that do not match and return cleaned data."];
	"build_site._apply_price_model"	[shape=box,
		tooltip="Predict prices in USD and guess missing currencies."];
	"price_utils.train_price_regression"	[shape=box,
		tooltip="Return ``(model, currency_map, counts)`` trained on ``lots``.

``lots`` must contain ``price`` and ``price:currency`` fields. Only \
lots with
embeddings present in ``id_to_vec`` are considered. Prices are regressed on
the logarithm scale so coefficients are interpretable \
as multiplicative
factors. ``USD`` is treated as the base currency so coefficients can be
interpreted as exchange rate multipliers. \
The returned ``counts`` dictionary
maps each currency to the number of training samples observed."];
	"build_site._apply_price_model" -> "price_utils.train_price_regression"	[minlen=1];
	"price_utils.predict_price"	[shape=box,
		tooltip="Return predicted price for ``vec`` in ``currency``.

When ``model`` is ``None`` or ``vec`` is missing, ``None`` is returned."];
	"build_site._apply_price_model" -> "price_utils.predict_price"	[minlen=2];
	"price_utils.currency_rates"	[shape=box,
		tooltip="Return estimated currency multipliers relative to the base.

The regression model learns one coefficient per currency dummy feature.  \
The
coefficient is the logarithm of the multiplier relative to USD."];
	"build_site._apply_price_model" -> "price_utils.currency_rates"	[minlen=3];
	"price_utils.guess_currency"	[shape=box,
		tooltip="Return currency with multiplier closest to ``price/pred_usd``.

``pred_usd`` is the predicted price in USD.  ``price`` is the numeric \
value
provided by the user without a currency.  The function compares the implied
multiplier ``price / pred_usd`` against the learnt \
exchange rates and picks
the closest match.  ``counts`` may be provided to ignore rarely seen
currencies when guessing.  Any currency \
with fewer than ``min_samples``
samples in the training set is skipped."];
	"build_site._apply_price_model" -> "price_utils.guess_currency"	[minlen=1];
	"build_site._similar_by_user"	[shape=box,
		tooltip="Return map of lot id to other lots from the same user."];
	"build_site._similar_by_user" -> "similar_utils._cos_sim";
	"build_site._categorise"	[shape=box,
		tooltip="Return category info and recent lot list."];
	"lot_io.get_seller"	[shape=box,
		tooltip="Return the seller identifier or ``None`` when missing."];
	"build_site._categorise" -> "lot_io.get_seller";
	"build_site._render_site"	[shape=box];
	"build_site.build_page"	[shape=box,
		tooltip="Render ``lot`` into separate HTML files for every language."];
	"build_site._render_site" -> "build_site.build_page";
	"similar_utils._format_vector"	[shape=box,
		tooltip="Return compact JSON representation for ``vec``."];
	"build_site._render_site" -> "similar_utils._format_vector";
	"build_site._render_site" -> "lot_io.get_seller";
	"build_site._render_site" -> "serde_utils.read_text";
	"build_site.build_page" -> "post_io.read_post";
	"build_site.build_page" -> "post_io.raw_post_path";
	"build_site.build_page" -> "build_site._env_for_lang";
	"caption_io.read_caption"	[shape=box,
		tooltip="Return caption for ``image`` in ``lang`` or empty string when missing."];
	"build_site.build_page" -> "caption_io.read_caption";
	"build_site.build_page" -> "similar_utils._format_vector";
	"build_site.main"	[shape=box];
	"build_site.main" -> "build_site._env_for_lang";
	"build_site.main" -> "build_site._copy_static"	[minlen=1];
	"build_site.main" -> "build_site._load_state";
	"build_site.main" -> "build_site._sync_embeddings"	[minlen=2];
	"build_site.main" -> "build_site._apply_price_model";
	"build_site.main" -> "build_site._similar_by_user"	[minlen=3];
	"build_site.main" -> "build_site._categorise"	[minlen=1];
	"build_site.main" -> "build_site._render_site";
	"similar_utils._save_similar"	[shape=box,
		tooltip="Write ``sim_map`` to ``SIMILAR_DIR`` mirroring ``LOTS_DIR`` layout."];
	"build_site.main" -> "similar_utils._save_similar";
	"similar_utils._prune_similar"	[shape=box,
		tooltip="Drop cache entries referring to ids not in ``valid_ids``."];
	"build_site.main" -> "similar_utils._prune_similar"	[minlen=2];
	"similar_utils._calc_similar_nn"	[shape=box,
		tooltip="Fill ``sim_map`` for ``new_ids`` using a nearest neighbour search.

``vec_ids`` lists all lots that have an embedding.  ``new_ids`` \
is a subset
for which we still need recommendations.  We gather vectors for
``vec_ids`` and use ``NearestNeighbors`` from scikit-learn \
to find the
closest items.  Embeddings of lots without a vector are skipped."];
	"build_site.main" -> "similar_utils._calc_similar_nn"	[minlen=3];
	"config_utils.load_config"	[shape=box,
		tooltip="Return the ``config`` module or exit with a helpful message.

When running the scripts directly from ``src/`` the repository root \
isn't on
``sys.path`` and ``config.py`` can't be imported.  Try adding the parent
directory before failing so the configuration \
can live alongside
``config.example.py`` in the project root."];
	"build_site.main" -> "config_utils.load_config";
	"debug_dump.parse_url"	[shape=box,
		tooltip="Return ``(lot_id, lang)`` extracted from ``url``."];
	"debug_dump.guess_source_from_lot"	[shape=box,
		tooltip="Guess ``(chat, message_id)`` directly from ``lot_id``."];
	"debug_dump.load_source_info"	[shape=box,
		tooltip="Return ``(chat, message_id)`` for ``lot_id`` if available."];
	"lot_io.lot_json_path"	[shape=box,
		tooltip="Return full JSON path for ``lot_id`` given ``root`` directory."];
	"debug_dump.load_source_info" -> "lot_io.lot_json_path";
	"debug_dump.load_source_info" -> "serde_utils.load_json";
	"debug_dump.run_tg_fetch"	[shape=box,
		tooltip="Run ``tg_client.py --fetch`` and return combined logs."];
	"debug_dump.run_tg_fetch" -> "serde_utils.read_text";
	"debug_dump.collect_files"	[shape=box,
		tooltip="Return ``[(name, content), ...]`` for files related to ``lot_id``."];
	"debug_dump.collect_files" -> "post_io.raw_post_path";
	"caption_io.caption_json_path"	[shape=box,
		tooltip="Return new-style caption path for ``image``."];
	"debug_dump.collect_files" -> "caption_io.caption_json_path";
	"caption_io.has_caption"	[shape=box,
		tooltip="Return ``True`` when any caption exists for ``image``."];
	"debug_dump.collect_files" -> "caption_io.has_caption";
	"debug_dump.collect_files" -> "caption_io.read_caption";
	"debug_dump.collect_files" -> "lot_io.lot_json_path";
	"debug_dump.collect_files" -> "serde_utils.read_text";
	"debug_dump.collect_files" -> "serde_utils.load_json";
	"debug_dump.delete_files"	[shape=box,
		tooltip="Remove files related to ``lot_id`` from the filesystem."];
	"debug_dump.delete_files" -> "post_io.raw_post_path";
	"debug_dump.delete_files" -> "caption_io.caption_json_path";
	"caption_io.caption_md_path"	[shape=box,
		tooltip="Return legacy Markdown caption path for ``image``."];
	"debug_dump.delete_files" -> "caption_io.caption_md_path";
	"debug_dump.delete_files" -> "lot_io.lot_json_path";
	"debug_dump.delete_files" -> "serde_utils.load_json";
	"debug_dump._message_reason"	[shape=box,
		tooltip="Return explanation why a message would be skipped."];
	"moderation.should_skip_user"	[shape=box,
		tooltip="Return ``True`` if ``username`` is blacklisted."];
	"debug_dump._message_reason" -> "moderation.should_skip_user";
	"debug_dump._lot_reason"	[shape=box,
		tooltip="Return explanation why ``lot`` would be skipped."];
	"debug_dump.moderation_summary"	[shape=box,
		tooltip="Return a multi-line summary of moderation checks for ``lot_id``."];
	"debug_dump.moderation_summary" -> "post_io.read_post";
	"debug_dump.moderation_summary" -> "post_io.raw_post_path";
	"debug_dump.moderation_summary" -> "debug_dump._message_reason"	[minlen=1];
	"debug_dump.moderation_summary" -> "debug_dump._lot_reason"	[minlen=2];
	"debug_dump.moderation_summary" -> "lot_io.lot_json_path";
	"debug_dump.moderation_summary" -> "serde_utils.load_json";
	"debug_dump.main"	[shape=box];
	"debug_dump.main" -> "debug_dump.parse_url"	[minlen=1];
	"debug_dump.main" -> "debug_dump.guess_source_from_lot"	[minlen=2];
	"debug_dump.main" -> "debug_dump.load_source_info";
	"debug_dump.main" -> "debug_dump.run_tg_fetch"	[minlen=3];
	"debug_dump.main" -> "debug_dump.collect_files";
	"debug_dump.main" -> "debug_dump.delete_files";
	"debug_dump.main" -> "debug_dump.moderation_summary";
	"caption_io._get_langs"	[shape=box,
		tooltip="Return configured languages, caching the result."];
	"caption_io._get_langs" -> "config_utils.load_config";
	"caption_io.has_caption" -> "caption_io.caption_json_path";
	"caption_io.has_caption" -> "caption_io.caption_md_path";
	"caption_io.read_caption" -> "caption_io._get_langs";
	"caption_io.read_caption" -> "caption_io.caption_json_path";
	"caption_io.read_caption" -> "caption_io.caption_md_path";
	"caption_io.read_caption" -> "serde_utils.read_md";
	"caption_io.read_caption" -> "serde_utils.load_json";
	"caption_io.write_caption"	[shape=box,
		tooltip="Write ``text`` as ``lang`` caption for ``image``."];
	"caption_io.write_caption" -> "caption_io._get_langs";
	"caption_io.write_caption" -> "caption_io.caption_json_path";
	"caption_io.write_caption" -> "serde_utils.load_json";
	"serde_utils.write_json"	[shape=box,
		tooltip="Serialise ``data`` to ``path`` with standard options."];
	"caption_io.write_caption" -> "serde_utils.write_json";
	"notes_utils.collect_notes"	[shape=box,
		tooltip="Return combined notes if ``notes/`` exists."];
	"notes_utils.collect_notes" -> "serde_utils.read_md"	[minlen=1];
	"message_utils.build_prompt"	[shape=box,
		tooltip="Return prompt combining message text with captioned file names."];
	"message_utils.gather_chop_input"	[shape=box,
		tooltip="Return the exact text fed to the lot parser for ``msg_path``."];
	"message_utils.gather_chop_input" -> "post_io.read_post";
	"message_utils.gather_chop_input" -> "caption_io.read_caption";
	"message_utils.gather_chop_input" -> "message_utils.build_prompt";
	"similar_utils._load_embeddings" -> "serde_utils.load_json";
	"similar_utils._similar_path"	[shape=box,
		tooltip="Return cache file path for ``lot_path`` under ``SIMILAR_DIR``."];
	"similar_utils._load_similar" -> "serde_utils.load_json";
	"similar_utils._save_similar" -> "similar_utils._similar_path"	[minlen=1];
	"similar_utils._save_similar" -> "lot_io.lot_json_path";
	"similar_utils._save_similar" -> "serde_utils.write_json";
	"similar_utils._update_reciprocal"	[shape=box,
		tooltip="Insert ``lot_id`` into caches of lots listed in ``sims`` if closer."];
	"similar_utils._calc_similar_nn" -> "similar_utils._update_reciprocal"	[minlen=1];
	"caption._identify_size"	[shape=box,
		tooltip="Return ``(width, height)`` for ``path`` using ImageMagick."];
	"caption._prepare_image"	[shape=box,
		tooltip="Resize ``path`` and return the processed JPEG bytes."];
	"caption._prepare_image" -> "caption._identify_size"	[minlen=1];
	"caption._guess_chat"	[shape=box,
		tooltip="Return chat name for ``path`` relative to ``MEDIA_DIR``."];
	"caption.caption_file"	[shape=box,
		tooltip="Caption ``path`` with GPT-4o and save ``.caption.json`` beside it."];
	"caption.caption_file" -> "caption_io.caption_json_path";
	"caption.caption_file" -> "caption_io.has_caption";
	"caption.caption_file" -> "caption._prepare_image"	[minlen=1];
	"caption.caption_file" -> "caption._guess_chat"	[minlen=2];
	"caption.caption_file" -> "serde_utils.load_json";
	"caption.caption_file" -> "serde_utils.write_json";
	"caption.main"	[shape=box];
	"caption.main" -> "caption.caption_file";
	"lot_io.embedding_path"	[shape=box,
		tooltip="Return embedding file path for ``lot_path``."];
	"phone_utils.format_georgian" -> "lot_io.embedding_path"	[style=invis];
	"clean_data._parse_date"	[shape=box,
		tooltip="Return the ``date`` field from a markdown file if present."];
	"clean_data._parse_date" -> "serde_utils.read_text";
	"clean_data._clean_raw"	[shape=box];
	"clean_data._clean_raw" -> "post_io.raw_post_path";
	"clean_data._clean_raw" -> "clean_data._parse_date";
	"clean_data._clean_media"	[shape=box];
	"clean_data._clean_media" -> "caption_io.has_caption";
	"clean_data._clean_media" -> "clean_data._parse_date";
	"clean_data._clean_lots"	[shape=box];
	"clean_data._clean_lots" -> "post_io.raw_post_path";
	"lot_io.needs_cleanup"	[shape=box,
		tooltip="Return ``True`` when ``clean_data`` would drop ``lots``."];
	"clean_data._clean_lots" -> "lot_io.needs_cleanup";
	"clean_data._clean_lots" -> "lot_io.read_lots";
	"clean_data._clean_embeddings"	[shape=box,
		tooltip="Delete embedding files when the matching lot JSON is absent."];
	"clean_data._remove_empty_dirs"	[shape=box,
		tooltip="Recursively remove empty folders under ``root``."];
	"clean_data.main"	[shape=box];
	"clean_data.main" -> "clean_data._clean_raw";
	"clean_data.main" -> "clean_data._clean_media";
	"clean_data.main" -> "clean_data._clean_lots";
	"clean_data.main" -> "clean_data._clean_embeddings"	[minlen=1];
	"clean_data.main" -> "clean_data._remove_empty_dirs"	[minlen=2];
	"chop.process_message"	[shape=box];
	"chop.process_message" -> "post_io.read_post";
	"chop.process_message" -> "caption_io.has_caption";
	"chop.process_message" -> "caption_io.read_caption";
	"chop.process_message" -> "message_utils.build_prompt";
	"chop.process_message" -> "moderation.should_skip_message";
	"lot_io.valid_lots"	[shape=box,
		tooltip="Return ``True`` when every lot contains the required translations."];
	"chop.process_message" -> "lot_io.valid_lots"	[minlen=1];
	"chop.process_message" -> "lot_io.needs_cleanup";
	"embed.embed_file"	[shape=box,
		tooltip="Embed ``path`` and write the result beside it under ``EMBED_DIR``."];
	"chop.process_message" -> "embed.embed_file";
	"token_utils.estimate_tokens"	[shape=box,
		tooltip="Return a naive token count approximation."];
	"chop.process_message" -> "token_utils.estimate_tokens"	[minlen=2];
	"chop.main"	[shape=box,
		tooltip="Process a single message file passed on the command line."];
	"chop.main" -> "chop.process_message";
	"moderation.should_skip_text"	[shape=box,
		tooltip="Return ``True`` if ``text`` contains banned phrases."];
	"moderation.message_skip_reason"	[shape=box,
		tooltip="Return the moderation reason for ``meta`` and ``text`` or ``None``."];
	"moderation.message_skip_reason" -> "moderation.should_skip_text"	[minlen=1];
	"moderation.message_skip_reason" -> "moderation.should_skip_user";
	"moderation.should_skip_message" -> "moderation.message_skip_reason";
	"moderation.lot_skip_reason"	[shape=box,
		tooltip="Return the moderation reason for ``lot`` or ``None``."];
	"moderation.should_skip_lot" -> "moderation.lot_skip_reason"	[minlen=1];
	"moderation.apply_to_history"	[shape=box,
		tooltip="Remove processed lots now failing moderation."];
	"moderation.apply_to_history" -> "post_io.read_post";
	"moderation.apply_to_history" -> "post_io.raw_post_path";
	"moderation.apply_to_history" -> "moderation.should_skip_message";
	"moderation.apply_to_history" -> "moderation.should_skip_lot";
	"moderation.apply_to_history" -> "lot_io.read_lots";
	"lot_io._clean_lot"	[shape=box,
		tooltip="Return ``lot`` without empty or null fields."];
	"lot_io.get_timestamp"	[shape=box,
		tooltip="Return ``lot['timestamp']`` as a timezone-aware ``datetime``."];
	"lot_io.read_lots" -> "lot_io._clean_lot";
	"lot_io.read_lots" -> "serde_utils.load_json";
	"lot_io.write_lots"	[shape=box,
		tooltip="Write lots to ``path`` using consistent JSON formatting."];
	"lot_io.write_lots" -> "lot_io._clean_lot";
	"lot_io.write_lots" -> "lot_io.get_seller";
	"lot_io.write_lots" -> "lot_io.get_timestamp"	[minlen=1];
	"lot_io.write_lots" -> "serde_utils.write_json";
	"lot_io.make_lot_id"	[shape=box,
		tooltip="Return lot id string for ``rel`` and ``index``.

``rel`` is the JSON file path relative to the ``data/lots`` directory
without the ``\
.json`` suffix."];
	"lot_io.parse_lot_id"	[shape=box,
		tooltip="Return ``(relative_path, index)`` extracted from ``lot_id``."];
	"lot_io.lot_json_path" -> "lot_io.parse_lot_id";
	"testing_mode.apply_testing_mode"	[shape=box];
	"lot_io.embedding_path" -> "testing_mode.apply_testing_mode"	[style=invis];
	"lot_io.get_lot"	[shape=box,
		tooltip="Return the lot identified by ``lot_id`` or ``None`` when missing."];
	"lot_io.get_lot" -> "lot_io.read_lots";
	"lot_io.get_lot" -> "lot_io.parse_lot_id";
	"embed.embed_file" -> "lot_io.read_lots";
	"embed.embed_file" -> "lot_io.make_lot_id"	[minlen=1];
	"embed.embed_file" -> "serde_utils.write_json";
	"embed.main"	[shape=box,
		tooltip="Embed the file given on the command line."];
	"embed.main" -> "embed.embed_file";
	"price_utils.canonical_currency"	[shape=box,
		tooltip="Return canonical currency code or ``None`` when unknown."];
	"price_utils.train_price_regression" -> "price_utils.canonical_currency"	[minlen=1];
	"image_io.read_image_meta"	[shape=box,
		tooltip="Return metadata from ``path.with_suffix('.md')``."];
	"serde_utils.parse_md"	[shape=box,
		tooltip="Return metadata dictionary and body text from ``path``."];
	"image_io.read_image_meta" -> "serde_utils.parse_md"	[minlen=1];
	"image_io.write_image_meta"	[shape=box,
		tooltip="Write ``meta`` to ``path.with_suffix('.md')``."];
	"image_io.write_image_meta" -> "serde_utils.write_md"	[minlen=1];
	"tg_client._mark_activity"	[shape=box,
		tooltip="Update ``_last_event`` to the current time."];
	"testing_mode.apply_testing_mode" -> "tg_client._mark_activity"	[style=invis];
	"scan_ontology._is_misparsed"	[shape=box,
		tooltip="Return ``True`` for obviously invalid lots or source posts."];
	"scan_ontology._is_misparsed" -> "lot_io.get_seller";
	"scan_ontology.collect_ontology"	[shape=box,
		tooltip="Return counts per field, value counters, misparsed lots and broken metadata."];
	"scan_ontology.collect_ontology" -> "post_io.read_post";
	"scan_ontology.collect_ontology" -> "post_io.raw_post_path";
	"scan_ontology.collect_ontology" -> "message_utils.gather_chop_input";
	"scan_ontology.collect_ontology" -> "lot_io.read_lots";
	"scan_ontology.collect_ontology" -> "scan_ontology._is_misparsed"	[minlen=1];
	"scan_ontology.main"	[shape=box];
	"scan_ontology.main" -> "scan_ontology.collect_ontology";
	"scan_ontology.main" -> "serde_utils.write_json";
	"log_utils.install_excepthook"	[shape=box,
		tooltip="Redirect uncaught exceptions to ``logger.exception``."];
	"scan_ontology.main" -> "log_utils.install_excepthook"	[minlen=1];
	"serde_utils.read_text" -> "serde_utils.read_text";
	"serde_utils.read_md" -> "serde_utils.read_text";
	"serde_utils.parse_md" -> "serde_utils.read_md";
	"serde_utils.load_json" -> "serde_utils.read_text";
	"tg_client._progress_logger"	[shape=box,
		tooltip="Return a progress callback that logs received bytes."];
	"tg_client._mark_activity" -> "tg_client._progress_logger"	[style=invis];
	"tg_client._write_md"	[shape=box,
		tooltip="Helper to store a raw post in Markdown format."];
	"tg_client._write_md" -> "post_io.write_post"	[minlen=1];
	"tg_client._scan_group_cache"	[shape=box,
		tooltip="Build group_id -> Path mapping for ``chat`` quickly."];
	"tg_client._scan_group_cache" -> "post_io.raw_post_path";
	"tg_client._find_group_path"	[shape=box,
		tooltip="Return stored message path for ``group_id`` if known."];
	"tg_client._find_group_path" -> "tg_client._scan_group_cache"	[minlen=1];
	"tg_client._get_message_path"	[shape=box,
		tooltip="Return path of stored message ``msg_id`` in ``chat`` if any."];
	"tg_client._get_message_path" -> "post_io.raw_post_path"	[minlen=2];
	"tg_client._should_skip_media"	[shape=box,
		tooltip="Return reason string if ``msg`` media should be skipped."];
	"tg_client._allowed_topic"	[shape=box,
		tooltip="Return ``True`` if ``msg`` belongs to an allowed forum topic."];
	"tg_client._should_skip_media" -> "tg_client._allowed_topic"	[style=invis];
	"tg_client._schedule_caption"	[shape=box,
		tooltip="Run captioning in a separate process so downloads continue."];
	"tg_client._allowed_topic" -> "tg_client._schedule_caption"	[style=invis];
	"tg_client._save_progress"	[shape=box,
		tooltip="Persist resume timestamp for ``chat`` to ``STATE_DIR``."];
	"tg_client._schedule_caption" -> "tg_client._save_progress"	[style=invis];
	"tg_client._schedule_chop"	[shape=box,
		tooltip="Run lot extraction in a separate process."];
	"tg_client._enqueue_chop"	[shape=box,
		tooltip="Queue ``path`` for chopping once captions are available."];
	"tg_client._enqueue_chop" -> "caption_io.has_caption";
	"tg_client._enqueue_chop" -> "moderation.should_skip_message";
	"tg_client._start_chop_worker"	[shape=box,
		tooltip="Ensure the chop queue worker task is running."];
	"tg_client._enqueue_chop" -> "tg_client._start_chop_worker"	[minlen=1];
	"tg_client._process_chop_queue"	[shape=box,
		tooltip="Check queued posts and chop cooled down ones."];
	"tg_client._process_chop_queue" -> "caption_io.has_caption";
	"tg_client._process_chop_queue" -> "tg_client._schedule_chop"	[minlen=1];
	"tg_client._get_id_date"	[shape=box,
		tooltip="Return the stored date for ``msg_id`` in ``chat`` if available."];
	"tg_client._get_id_date" -> "post_io.raw_post_path";
	"tg_client._get_id_date" -> "serde_utils.read_text";
	"tg_client._load_progress"	[shape=box,
		tooltip="Return saved resume timestamp for ``chat`` if available."];
	"tg_client._load_progress" -> "serde_utils.read_text"	[minlen=3];
	"telegram_bot:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"tg_client._save_progress" -> "telegram_bot:cli"	[style=invis];
	"tg_client.get_first_id"	[shape=box,
		tooltip="Return the smallest saved message id for ``chat``."];
	"tg_client.get_first_id" -> "post_io.raw_post_path"	[minlen=3];
	"tg_client.get_last_id"	[shape=box,
		tooltip="Return the highest saved message id for ``chat``."];
	"tg_client.get_last_id" -> "post_io.raw_post_path"	[minlen=1];
	"tg_client._remove_local_message"	[shape=box,
		tooltip="Delete ``path`` and related media if the post no longer exists."];
	"tg_client._remove_local_message" -> "post_io.read_post";
	"tg_client._remove_local_message" -> "caption_io.caption_json_path";
	"tg_client._remove_local_message" -> "caption_io.caption_md_path";
	"log_utils._extract_tb_lineno"	[shape=box,
		tooltip="Return the last line number from a traceback."];
	"log_utils._add_exc_line"	[shape=box,
		tooltip="Attach ``line`` from traceback to structured log events."];
	"log_utils._add_exc_line" -> "log_utils._extract_tb_lineno"	[minlen=1];
	"log_utils.init_logger"	[shape=box,
		tooltip="Initialize logger writing to ``LOGFILE``.

``LOG_LEVEL`` may be set in ``config.py`` or via an environment
variable.  The level \
accepts ``DEBUG``, ``INFO`` or ``ERROR`` and
defaults to ``INFO``.  The function falls back to the standard
``logging`` module if ``\
structlog`` isn't available so the scripts
can still run in minimal environments."];
	"log_utils.init_logger" -> "log_utils._extract_tb_lineno";
	"log_utils.get_logger"	[shape=box,
		tooltip="Return the singleton logger instance."];
	"log_utils.init_logger" -> "log_utils.get_logger"	[minlen=1];
	"log_utils.get_logger" -> "log_utils.init_logger";
	"log_utils.install_excepthook" -> "log_utils._extract_tb_lineno";
	"build_site:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"telegram_bot:cli" -> "build_site:cli"	[style=invis];
	"debug_dump:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"build_site:cli" -> "debug_dump:cli"	[style=invis];
	"caption:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"clean_data:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"caption:cli" -> "clean_data:cli"	[style=invis];
	"chop:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"clean_data:cli" -> "chop:cli"	[style=invis];
	"moderation:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"chop:cli" -> "moderation:cli"	[style=invis];
	"embed:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"moderation:cli" -> "embed:cli"	[style=invis];
	"scan_ontology:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"embed:cli" -> "scan_ontology:cli"	[style=invis];
	"tg_client:cli"	[shape=box,
		tooltip="Command line entrypoint"];
	"scan_ontology:cli" -> "tg_client:cli"	[style=invis];
	build_site:cli -> "build_site.main"	[minlen=1];
	caption:cli -> "caption.main"	[minlen=1];
	chop:cli -> "chop.main"	[minlen=1];
	clean_data:cli -> "clean_data.main"	[minlen=1];
	debug_dump:cli -> "debug_dump.main"	[minlen=1];
	embed:cli -> "embed.main"	[minlen=1];
	moderation:cli -> "moderation.apply_to_history"	[minlen=1];
	scan_ontology:cli -> "scan_ontology.main"	[minlen=1];
}
