"""Render static HTML pages from JSON lots using Jinja2.

Each ``*.json`` file under ``data/lots`` may contain several lots so we assign
a unique ``_page_id`` to every entry.  Templates live in ``templates/`` and the
output is written to ``data/views`` keeping the directory layout intact.  The
script also loads embeddings from ``data/embeddings`` if present to find similar
lots based on cosine similarity.  ``data/ontology/fields.json`` is consulted to
display table columns in a stable order.
"""

import os
from pathlib import Path
import shutil
import subprocess
from datetime import datetime, timedelta, timezone

from jinja2 import Environment, FileSystemLoader
import gettext
from notes_utils import load_json
from lot_io import (
    read_lots,
    get_seller,
    get_timestamp,
    iter_lot_files,
)
from similar_utils import (
    SIMILAR_DIR,
    _load_embeddings,
    _format_vector,
    _load_similar,
    _load_more_user,
    _sync_embeddings,
)

from config_utils import load_config
from log_utils import get_logger, install_excepthook
from moderation import should_skip_message, should_skip_lot
from post_io import read_post, raw_post_path, RAW_DIR
from caption_io import read_caption
from price_utils import (
    apply_price_model,
    fetch_official_rates,
    canonical_currency,
    load_price_model,
    prepare_price_fields,
)

log = get_logger().bind(script=__file__)
install_excepthook(log)

LOTS_DIR = Path("data/lots")
VIEWS_DIR = Path("data/views")
TEMPLATES = Path("templates")
EMBED_DIR = Path("data/embeddings")
ONTOLOGY = Path("data/ontology/fields.json")
LOCALE_DIR = Path("locale")
MEDIA_DIR = Path("data/media")
MODEL_FILE = Path("data/price_model.json")
CLUSTER_FILE = Path("data/item_clusters.json")



def _load_ontology() -> list[str]:
    """Return sorted field list from ``ONTOLOGY`` or empty list when missing."""
    if not ONTOLOGY.exists():
        return []
    data = load_json(ONTOLOGY)
    if not isinstance(data, dict):
        log.error("Bad ontology", path=str(ONTOLOGY))
        return []
    fields = sorted(data.keys())
    log.info("Loaded ontology", count=len(fields))
    return fields


def _load_clusters() -> dict[str, list[str]]:
    """Return precomputed item clusters."""
    if not CLUSTER_FILE.exists():
        return {}
    data = load_json(CLUSTER_FILE)
    if not isinstance(data, dict):
        log.error("Bad cluster file", path=str(CLUSTER_FILE))
        return {}
    result: dict[str, list[str]] = {}
    for name, ids in data.items():
        if isinstance(name, str) and isinstance(ids, list):
            result[name] = [str(i) for i in ids if isinstance(i, str)]
    if result:
        log.info("Loaded clusters", count=len(result))
    return result


def _compile_locale(lang: str) -> None:
    """Compile ``lang`` gettext catalogue when out of date."""
    po = LOCALE_DIR / lang / 'LC_MESSAGES' / 'messages.po'
    mo = po.with_suffix('.mo')
    if not po.exists():
        return
    if not mo.exists() or po.stat().st_mtime > mo.stat().st_mtime:
        try:
            subprocess.run(['msgfmt', str(po), '-o', str(mo)], check=True)
            log.debug('Compiled translation', lang=lang)
        except Exception:
            log.exception('Failed to compile translation', lang=lang)


def _env_for_lang(lang: str) -> Environment:
    """Return Jinja environment configured for ``lang``."""
    _compile_locale(lang)
    env = Environment(
        loader=FileSystemLoader(str(TEMPLATES)),
        extensions=['jinja2.ext.i18n'],
    )
    mo = LOCALE_DIR / lang / 'LC_MESSAGES' / 'messages.mo'
    try:
        trans = gettext.GNUTranslations(mo.open('rb'))
    except Exception:
        trans = gettext.NullTranslations()
    # Translation files use ``%(name)s`` placeholders generated by gettext,
    # so stick to the classic percent formatting style.  ``newstyle`` would
    # expect ``{name}`` placeholders which our .po files don't contain and
    # would trigger ``ValueError`` when rendering.
    env.install_gettext_translations(trans, newstyle=False)
    return env






def _iter_lots() -> list[dict]:
    """Return all lots ready for rendering."""
    lots = []
    # ``iter_lot_files`` keeps file ordering consistent with ``pending_embed.py``
    # so both scripts see the same data in the same order.
    for path in iter_lot_files(LOTS_DIR):
        data = read_lots(path)
        if not data:
            continue
        rel = path.relative_to(LOTS_DIR).with_suffix("")
        base = rel.name
        prefix = rel.parent
        for i, lot in enumerate(data):
            src = lot.get("source:path")
            meta: dict[str, str] | None = None
            text = ""
            if src:
                raw_path = raw_post_path(src, RAW_DIR)
                meta, text = read_post(raw_path)
                if should_skip_message(meta, text):
                    log.info(
                        "Skipping lot",
                        file=str(path),
                        reason="moderation",
                        source=str(src),
                    )
                    continue
            if should_skip_lot(lot):
                log.info(
                    "Skipping lot",
                    file=str(path),
                    reason="moderation",
                    source=str(src) if src else None,
                )
                continue
            lot["_file"] = path
            lot["_id"] = str(prefix / f"{base}-{i}") if prefix.parts else f"{base}-{i}"
            lots.append(lot)
    log.info("Loaded lots", count=len(lots))
    return lots


def _copy_images(lots: list[dict]) -> None:
    """Copy media referenced by ``lots`` into ``VIEWS_DIR``."""
    media_dst = VIEWS_DIR / "media"
    if media_dst.exists():
        shutil.rmtree(media_dst)
    for lot in lots:
        for rel in lot.get("files", []):
            src = MEDIA_DIR / rel
            if not src.exists():
                continue
            dst = media_dst / rel
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)


def _copy_static() -> None:
    """Copy CSS and JS so generated pages are standalone."""
    static_src = TEMPLATES / "static"
    static_dst = VIEWS_DIR / "static"
    if static_src.exists():
        if static_dst.exists():
            shutil.rmtree(static_dst)
        shutil.copytree(static_src, static_dst)
        log.debug("Copied static assets", src=str(static_src), dst=str(static_dst))



def _load_state() -> tuple[
    list[str],
    dict[str, list[float]],
    list[dict],
    dict[str, list[dict]],
    dict[str, list[dict]],
    dict[str, list[str]],
]:
    """Return ontology fields, embeddings, lots and similarity caches."""
    log.debug("Loading ontology")
    fields = _load_ontology()
    log.debug("Loading embeddings")
    embeddings = _load_embeddings()
    log.debug("Loading lots")
    lots = _iter_lots()
    _copy_images(lots)
    log.debug("Loading similar cache")
    sim_map = _load_similar()
    log.debug("Loading user cache")
    more_user_map = _load_more_user()
    log.debug("Loading clusters")
    clusters = _load_clusters()
    return fields, embeddings, lots, sim_map, more_user_map, clusters




def _categorise(
    lots: list[dict],
    langs: list[str],
    keep_days: int,
    id_to_vec: dict[str, list[float]],
    clusters: dict[str, list[str]] | None,
) -> tuple[dict[str, list[dict]], dict[str, dict], list[dict]]:
    """Return category info and recent lot list.

    Categories are split by ``market:deal``. ``sell_item`` lots are further
    grouped by ``clusters`` when available and fall back to ``item:type``.
    Stats include price range, last timestamp and embedding centroid so the
    sorting logic used on item pages also works for categories.
    """
    now = datetime.now(timezone.utc)
    recent_cutoff = now - timedelta(days=keep_days)
    recent: list[dict] = []
    categories: dict[str, list[dict]] = {}
    category_stats: dict[str, dict] = {}
    lid_to_cluster: dict[str, str] = {}
    if clusters:
        for name, ids in clusters.items():
            for lid in ids:
                lid_to_cluster[lid] = name
    def update_stat(cat: str) -> dict:
        stat = category_stats.setdefault(
            cat,
            {
                "recent": 0,
                "users": set(),
                "recent_users": set(),
                "prices": [],
                "prices_usd": [],
                "times": [],
                "vecsum": None,
                "count": 0,
            },
        )
        return stat

    def add_lot(cat: str, lot: dict, dt: datetime | None) -> None:
        categories.setdefault(cat, []).append(lot)
        stat = update_stat(cat)
        user = get_seller(lot)
        if isinstance(user, list):
            log.debug("Multiple sellers", id=lot.get("_id"), value=user)
            user = user[0] if user else None
        if user:
            stat["users"].add(str(user))
        if dt and dt >= recent_cutoff:
            if user:
                stat["recent_users"].add(str(user))
            stat["recent"] += 1
        price = lot.get("_display_value")
        if price not in ("", None):
            try:
                stat["prices"].append(float(price))
            except Exception:
                pass
        usd = lot.get("_usd_value")
        if usd not in ("", None):
            try:
                stat["prices_usd"].append(float(usd))
            except Exception:
                pass
        if dt:
            stat["times"].append(dt)
        vec = id_to_vec.get(lot.get("_id"))
        if vec:
            if stat["vecsum"] is None:
                stat["vecsum"] = [0.0 for _ in vec]
            for i, v in enumerate(vec):
                stat["vecsum"][i] += v
            stat["count"] += 1

    for lot in lots:
        dt = get_timestamp(lot)
        deal = lot.get("market:deal", "misc")
        if not isinstance(deal, str):
            log.debug("Non-string deal", id=lot.get("_id"), value=deal)
            if isinstance(deal, list) and deal:
                deal = deal[0]
            else:
                deal = str(deal)

        add_lot(deal, lot, dt)

        if deal == "sell_item":
            cname = lid_to_cluster.get(lot["_id"])
            if cname:
                add_lot(f"{deal}.{cname}", lot, dt)
            else:
                itype = lot.get("item:type")
                if isinstance(itype, list):
                    itype = itype[0] if itype else None
                if isinstance(itype, str) and itype:
                    add_lot(f"{deal}.{itype}", lot, dt)

        if dt and dt >= recent_cutoff:
            titles = {lang: lot.get(f"title_{lang}") for lang in langs}
            seller = get_seller(lot)
            recent.append(
                {
                    "id": lot["_id"],
                    "titles": titles,
                    "dt": dt,
                    "price": lot.get("_display_price"),
                    "price_class": lot.get("_price_class"),
                    "seller": seller,
                }
            )

    for cat, stat in category_stats.items():
        prices = stat.pop("prices")
        prices_usd = stat.pop("prices_usd")
        times = stat.pop("times")
        vecsum = stat.pop("vecsum")
        count = stat.pop("count")
        if prices:
            prices_sorted = sorted(prices)
            mid = len(prices_sorted) // 2
            if len(prices_sorted) % 2:
                stat["price_typical"] = prices_sorted[mid]
            else:
                stat["price_typical"] = (
                    prices_sorted[mid - 1] + prices_sorted[mid]
                ) / 2
            stat["price_min"] = prices_sorted[0]
            stat["price_max"] = prices_sorted[-1]
        else:
            stat["price_typical"] = stat["price_min"] = stat["price_max"] = None
        if prices_usd:
            prices_sorted = sorted(prices_usd)
            mid = len(prices_sorted) // 2
            if len(prices_sorted) % 2:
                stat["price_typical_usd"] = prices_sorted[mid]
            else:
                stat["price_typical_usd"] = (
                    prices_sorted[mid - 1] + prices_sorted[mid]
                ) / 2
        else:
            stat["price_typical_usd"] = None
        stat["last_dt"] = max(times) if times else None
        if vecsum is not None and count:
            stat["centroid"] = [v / count for v in vecsum]
        else:
            stat["centroid"] = None

    if not os.environ.get("ALLOW_EMPTY_POSTERS"):
        for cat, lots_list in categories.items():
            assert lots_list, f"No lots for category {cat}"
            assert category_stats[cat]["users"], f"No posters for category {cat}"

    return categories, category_stats, recent


def _render_site(
    lots: list[dict],
    fields: list[str],
    langs: list[str],
    envs: dict[str, Environment],
    keep_days: int,
    id_to_vec: dict[str, list[float]],
    lookup: dict[str, dict],
    sim_map: dict[str, list[dict]],
    more_user_map: dict[str, list[dict]],
    categories: dict[str, list[dict]],
    category_stats: dict[str, dict],
    rates: dict[str, float],
    display_cur: str,
) -> None:
    """Render all HTML pages for ``lots`` using cached templates.

    ``envs`` supplies jinja environments for every language so they are
    initialised only once. ``rates`` maps currency codes to multipliers relative
    to USD.  The values are embedded into the pages so the front-end can
    convert prices on the fly.
    """
    for lot in lots:
        log.debug("Rendering", id=lot["_id"])
        build_page(
            lot,
            sim_map.get(lot["_id"], []),
            more_user_map.get(lot["_id"], []),
            fields,
            langs,
            id_to_vec.get(lot["_id"]),
            lookup,
            rates,
            display_cur,
            envs,
        )

    log.debug("Writing category pages")
    cat_tpls = {lang: envs[lang].get_template("category.html") for lang in langs}
    subcat_tpls = {lang: envs[lang].get_template("category_index.html") for lang in langs}
    cat_dir = VIEWS_DIR / "deal"
    cat_dir.mkdir(parents=True, exist_ok=True)
    child_map: dict[str, list[str]] = {}
    for name in categories:
        if "." in name:
            base, _ = name.split(".", 1)
            child_map.setdefault(base, []).append(name)

    for deal, lot_list in categories.items():
        lot_list_sorted = sorted(
            lot_list,
            key=lambda x: get_timestamp(x) or datetime.min,
            reverse=True,
        )
        for lang in langs:
            items_lang = []
            subcats = child_map.get(deal)
            if subcats:
                for sub in subcats:
                    stat = category_stats.get(sub, {})
                    items_lang.append(
                        {
                            "link": os.path.relpath(cat_dir / f"{sub}_{lang}.html", cat_dir),
                            "name": sub.split(".", 1)[1],
                            "recent": stat.get("recent", 0),
                            "users": len(stat.get("recent_users", set())),
                            "price": f"{stat['price_typical']:.2f} {display_cur}" if stat.get('price_typical') is not None else "",
                            "price_value": stat.get("price_typical") or "",
                            "price_usd": stat.get("price_typical_usd"),
                            "dt": stat.get("last_dt"),
                            "embed": _format_vector(stat.get("centroid")),
                        }
                    )
                tpl = subcat_tpls[lang]
                render_args = {"deal": deal, "categories": items_lang}
            else:
                for lot in lot_list_sorted:
                    title = lot.get(f"title_{lang}") or next(
                        (lot.get(f"title_{l}") for l in langs if lot.get(f"title_{l}")),
                        lot.get("_id"),
                    )
                    seller = get_seller(lot)
                    dt = get_timestamp(lot)
                    items_lang.append(
                        {
                            "link": os.path.relpath(
                                VIEWS_DIR / f"{lot['_id']}_{lang}.html",
                                cat_dir,
                            ),
                            "title": title,
                            "dt": dt,
                            "price": lot.get("_display_price"),
                            "price_class": lot.get("_price_class"),
                            "price_value": lot.get("_display_value"),
                            "price_usd": lot.get("_usd_value"),
                            "seller": seller,
                            "id": lot["_id"],
                            "embed": _format_vector(id_to_vec.get(lot["_id"])),
                        }
                    )
                tpl = cat_tpls[lang]
                render_args = {"deal": deal, "items": items_lang}

            out = cat_dir / f"{deal}_{lang}.html"
            breadcrumbs = [
                {"title": "Home", "link": os.path.relpath(VIEWS_DIR / f"index_{lang}.html", cat_dir)},
                {"title": deal, "link": None},
            ]
            render_args.update(
                {
                    "langs": langs,
                    "current_lang": lang,
                    "page_basename": deal,
                    "title": deal,
                    "static_prefix": os.path.relpath(VIEWS_DIR / "static", cat_dir),
                    "breadcrumbs": breadcrumbs,
                    "rates": rates,
                    "display_cur": display_cur,
                    "keep_days": keep_days,
                }
            )
            out.write_text(tpl.render(**render_args))
            log.debug("Wrote", path=str(out))

    log.debug("Writing index pages")
    index_tpls = {lang: envs[lang].get_template("index.html") for lang in langs}
    for lang in langs:
        cats_lang = []
        for deal, stat in category_stats.items():
            if "." in deal:
                continue
            cats_lang.append(
                {
                    "link": os.path.relpath(cat_dir / f"{deal}_{lang}.html", VIEWS_DIR),
                    "deal": deal,
                    "recent": stat["recent"],
                    "users": len(stat.get("recent_users", set())),
                    "price": f"{stat['price_typical']:.2f} {display_cur}" if stat.get('price_typical') is not None else "",
                    "price_value": stat.get("price_typical") or "",
                    "price_usd": stat.get("price_typical_usd"),
                    "dt": stat.get("last_dt"),
                    "embed": _format_vector(stat.get("centroid")),
                }
            )
        out = VIEWS_DIR / f"index_{lang}.html"
        breadcrumbs = [{"title": "Home", "link": f"index_{lang}.html"}]
        out.write_text(
            index_tpls[lang].render(
                categories=cats_lang,
                langs=langs,
                current_lang=lang,
                page_basename="index",
                title="Index",
                static_prefix=os.path.relpath(VIEWS_DIR / "static", VIEWS_DIR),
                breadcrumbs=breadcrumbs,
                keep_days=keep_days,
                rates=rates,
                display_cur=display_cur,
            )
        )
        log.debug("Wrote", path=str(out))
    if langs:
        default = VIEWS_DIR / "index.html"
        src = VIEWS_DIR / f"index_{langs[0]}.html"
        default.write_text(src.read_text())
        log.debug("Wrote", path=str(default))



def build_page(
    lot: dict,
    similar: list[dict],
    more_user: list[dict],
    fields: list[str],
    langs: list[str],
    embedding: list[float] | None,
    lookup: dict[str, dict],
    rates: dict[str, float],
    display_cur: str,
    envs: dict[str, Environment],
) -> None:
    """Render ``lot`` into separate HTML files for every language.

    ``rates`` provides currency multipliers used by the front-end for dynamic
    conversion. ``envs`` preloads jinja environments to avoid expensive
    reinitialisation for each page.
    """
    for lang in langs:
        env = envs[lang]
        images = []
        for rel in lot.get("files", []):
            p = MEDIA_DIR / rel
            caption = read_caption(p, lang)
            images.append({"path": rel, "caption": caption})

        # Drop internal helper fields that are meaningless to end users.
        attrs = {
            k: v
            for k, v in lot.items()
            if k not in {"files", "ai_price"}
            and not k.startswith("title_")
            and not k.startswith("description_")
            and not k.startswith("source:")
            and not k.startswith("_")
            and v not in ("", None)
        }
        if "price" not in attrs and lot.get("ai_price") is not None:
            attrs["price"] = lot["_display_price"]
        elif "price" in attrs:
            attrs["price"] = lot.get("_display_price", attrs["price"])
        sorted_attrs = {k: attrs[k] for k in fields if k in attrs}
        for k in attrs:
            if k not in sorted_attrs:
                sorted_attrs[k] = attrs[k]

        ts = sorted_attrs.get("timestamp")
        dt = get_timestamp(lot)
        if ts and dt is None:
            del sorted_attrs["timestamp"]

        # Show the original message text for context if available.
        orig_text = ""
        src = lot.get("source:path")
        if src:
            _, orig_text = read_post(raw_post_path(src, RAW_DIR))

        chat = lot.get("source:chat")
        mid = lot.get("source:message_id")
        tg_link = f"https://t.me/{chat}/{mid}" if chat and mid else ""

        template = env.get_template("lot.html")
        out = VIEWS_DIR / f"{lot['_id']}_{lang}.html"
        out.parent.mkdir(parents=True, exist_ok=True)

        page_similar = []
        for item in similar:
            other = lookup.get(item["id"], {})
            title = (
                other.get(f"title_{lang}")
                or other.get("title_en")
                or next(
                    (other.get(f"title_{l}") for l in langs if other.get(f"title_{l}")),
                    item["id"],
                )
            )
            files = other.get("files") or []
            thumb = files[0] if files else ""
            page_similar.append(
                {
                    "link": os.path.relpath(
                        VIEWS_DIR / f"{item['id']}_{lang}.html",
                        out.parent,
                    ),
                    "title": title,
                    "thumb": thumb,
                }
            )
        page_user = []
        for item in more_user:
            other = lookup.get(item["id"], {})
            title = (
                other.get(f"title_{lang}")
                or other.get("title_en")
                or next(
                    (other.get(f"title_{l}") for l in langs if other.get(f"title_{l}")),
                    item["id"],
                )
            )
            files = other.get("files") or []
            thumb = files[0] if files else ""
            page_user.append(
                {
                    "link": os.path.relpath(
                        VIEWS_DIR / f"{item['id']}_{lang}.html",
                        out.parent,
                    ),
                    "title": title,
                    "thumb": thumb,
                }
            )
        static_prefix = os.path.relpath(VIEWS_DIR / "static", out.parent)
        media_prefix = os.path.relpath(VIEWS_DIR / "media", out.parent)
        home_link = os.path.relpath(VIEWS_DIR / f"index_{lang}.html", out.parent)
        page_basename = Path(lot['_id']).name
        breadcrumbs = [{"title": "Home", "link": home_link}]
        deal = lot.get("market:deal")
        if isinstance(deal, list):
            deal = deal[0] if deal else None
        if deal:
            cat_link = os.path.relpath(
                VIEWS_DIR / "deal" / f"{deal}_{lang}.html",
                out.parent,
            )
            breadcrumbs.append({"title": deal, "link": cat_link})
        breadcrumbs.append({"title": lot.get(f"title_{lang}") or lot['_id'], "link": None})
        embed_str = _format_vector(embedding)
        out.write_text(
            template.render(
                title=lot.get(f"title_{lang}", "Lot"),
                lot=lot,
                images=images,
                attrs=sorted_attrs,
                orig_text=orig_text,
                description=lot.get(f"description_{lang}", ""),
                tg_link=tg_link,
                similar=page_similar,
                more_user=page_user,
                langs=langs,
                current_lang=lang,
                page_basename=page_basename,
                static_prefix=static_prefix,
                media_prefix=media_prefix,
                breadcrumbs=breadcrumbs,
                embed=embed_str,
                rates=rates,
                display_cur=display_cur,
            )
        )
        log.debug("Wrote", path=str(out))


def main() -> None:
    """Build the static site under ``VIEWS_DIR``."""
    log.info("Building site")
    cfg = load_config()
    langs = getattr(cfg, "LANGS", ["en"])
    keep_days = getattr(cfg, "KEEP_DAYS", 7)
    display_cur = canonical_currency(getattr(cfg, "DISPLAY_CURRENCY", "USD")) or "USD"
    envs = {lang: _env_for_lang(lang) for lang in langs}
    VIEWS_DIR.mkdir(parents=True, exist_ok=True)

    _copy_static()
    fields, embeddings, lots, sim_map, more_user_map, clusters = _load_state()
    lots, embeddings = _sync_embeddings(lots, embeddings)

    id_to_vec = {lot["_id"]: embeddings.get(lot["_id"]) for lot in lots}
    lookup = {lot["_id"]: lot for lot in lots}

    rates_official = fetch_official_rates()
    model, cur_map, counts = load_price_model(MODEL_FILE)
    ai_rates = apply_price_model(
        lots,
        id_to_vec,
        rates_official,
        model,
        cur_map,
        counts,
    )

    if rates_official:
        use_rates = rates_official
    else:
        use_rates = ai_rates
    prepare_price_fields(lots, use_rates, display_cur)

    categories, category_stats, _recent = _categorise(
        lots, langs, keep_days, id_to_vec, clusters
    )

    _render_site(
        lots,
        fields,
        langs,
        envs,
        keep_days,
        id_to_vec,
        lookup,
        sim_map,
        more_user_map,
        categories,
        category_stats,
        use_rates,
        display_cur,
    )

    log.info("Site build complete")


if __name__ == "__main__":
    main()
